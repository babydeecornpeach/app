<link rel="import" href="../../../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../../../bower_components/iron-icon/iron-icon.html">

<dom-module id="file-explorer">
	<template >
		<style include="iron-flex">
			:host {
				display: block;
				height: 100%;
			}
		</style>
		<template id="repeat" is="dom-repeat" items="{{children(tree)}}">
			<file-explorer-file name="{{item.key}}" file="{{item.value}}" path=""></file-explorer-file>
		</template>
		<paper-toast id="toast"></paper-toast>
	</template>
	<script>
		Polymer({
			is: 'file-explorer',
			properties: {
				language: {
					type: String,
					notify: true,
					reflectToAttribute: true
				},
				tree: {
					type: Object,
					notify: true
				},
				names: {
					value: {
						good: /^[a-zA-Z0-9-_~\.]{1,255}$/,
						bad: ['.', '..']
					}
				},
				cachedPath: {
					value: ''
				}
			},
			listeners: {
				'rename': 'onRename',
				'delete': 'onDelete',
				'add-file': 'onAddFile',
				'add-folder': 'onAddFolder',
				'file-selected': '_fileSelected',
				'contextmenu': 'showContextMenu'
			},
			ready: function() {
				if (!!localStorage.cachedCode) {
					this.tree = JSON.parse(localStorage.cachedCode);
					return;
				}
				this.tree = {};
			},
			clear: function() {
				// FIXME(flowlo): Why are we setting this to undefined and then to tree?
				this.tree = undefined;
				this.tree = {};
				this.$.repeat.render();
			},
			_fileSelected: function(e, detail) {
				this.setLanguageByExtension(detail.name);
			},
			update: function(path, name, content) {
				this.insertFile(path + '/' + name, content);
				localStorage.cachedCode = JSON.stringify(this.tree);
			},
			onAddFile: function(e) {
				this.insertFile(e.detail.path, '');
				this.refreshTree();
			},
			onAddFolder: function(e) {
				this.insertFile(e.detail.path, {});
				this.refreshTree();
			},
			onDelete: function(e) {
				this.deleteFile(e.detail.path);
				this.refreshTree();
			},
			onRename: function(e) {
				var copy = this.getFile(e.detail.from);
				this.deleteFile(e.detail.from);
				this.insertFile(e.detail.to, copy);
				this.refreshTree(this.tree);
			},
			addFile: function(path, content) {
				var tree = this.tree;
				if (!this.addItem(tree, path, content)) {
					return;
				}

				this.setLanguageByExtension(path);
				this.refreshTree(tree);
			},
			setLanguageByExtension: function(path) {
				var i = path.lastIndexOf('.');
				if (i < 0) {
					return;
				}
				this.language = path.substring(i + 1);
			},
			addItem: function(tree, path, item) {
				var splitValue = path.split('/');
				var itemName = splitValue[splitValue.length - 1];
				if (!this.names.good.test(itemName)) {
					this.showToast('Name is not valid.');
					return false;
				}
				if (itemName === '') {
					this.showToast('Name cannot be empty.');
					return false;
				}
				var path = this.splitPath(path);

				var node = this.getNodeForPathArray(tree, path.slice(0, path.length - 1));
				if (node === undefined) {
					return false;
				}
				if (typeof node !== 'object') {
					this.showToast('You cannot transform files in folders!');
					return false;
				}
				var name = path.pop();
				if (!!node[name]) {
					this.showToast('Name already exists!');
					return false;
				}
				node[name] = item;
				return true;
			},
			splitPath: function(path) {
				if (!path) {
					return undefined;
				}

				// Path is not rooted at /
				if (path[0] !== '/') {
					return undefined;
				}

				return path.substring(1).split('/');
			},
			deleteFile: function(fullPath) {
				var path = this.splitPath(fullPath);

				var file = this.tree;
				for (var i = 0; i < path.length - 1; i++) {
					file = file[path[i]];
				}

				if (!file) {
					return;
				}

				delete file[path[path.length - 1]];
			},
			getFile: function(fullPath) {
				var path = this.splitPath(fullPath);

				var file = this.tree;
				for (var i = 0; i < path.length; i++) {
					file = file[path[i]];
				}

				return file;
			},
			insertFile: function(fullPath, content) {
				var path = this.splitPath(fullPath);

				var file = this.tree;
				for (var i = 0; i < path.length - 1; i++) {
					if (!file[path[i]]) {
						file[path[i]] = {};
					}
					file = file[path[i]];
				}

				file[path[path.length - 1]] = content;
			},
			refreshTree: function(tree) {
				if (!tree) {
					tree = this.tree;
				}
				this.tree = JSON.parse(JSON.stringify(tree));
				this.$.repeat.render();
			},
			getPathsRecursively: function(file, path) {
				if (!path) {
					path = '';
				}

				var fullPath = path + '/' + file.name;
				var that = this;
				return Object.keys(file.value).map(function(k) {
					return that.getPathsRecursively(file.value[k], fullPath);
				}).reduce(function(a, b) {
					return a.concat(b);
				}, []).concat([{
					path: fullPath,
					value: file.value
				}]);
			},
			getFiles: function() {
				var tree = this.tree;

				var elements = [];
				this.getPathsRecursively(tree, elements, '');
				return elements.map(function(it) {
					var blob = new Blob([it.value]);
					blob.name = it.path;
					console.log(blob);
					return blob;
				});
			},
			showToast: function(message) {
				this.$.toast.text = message;
				this.$.toast.show();
			},
			children: function(file) {
				if (!file) {
					return [];
				}
				return Object.keys(file).sort().map(function(k) {
					return {
						key: k,
						value: file[k]
					};
				});
			},
			showContextMenu: function(e) {
				e.preventDefault();
				this.fire('show-menu', {
					'x': e.pageX,
					'y': e.pageY
				});
			}
		});
	</script>
</dom-module>
